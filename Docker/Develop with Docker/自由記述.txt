【メモ】

・Using Kubernetes for remote development
大規模なクラウドネイティブアプリケーションを開発しているチームが、ローカルに実行できない。
ローカルマシンが提供できる以上のリソースが必要、依存関係がある。テストと検証には大量の
データまたはネットワークトラフィックが必要など。

・Combining local and remote
ローカルサービスをリモート開発クラスターと統合する方法を紹介している。ローカルサービスがネットワーク
経由で開発クラスターと通信できるようにする。内部ループの簡素化と高速化に役立ち、商用および
オープンソースのツールも。

・Telepresence
Telepresence は、ローカル サービスをリモート Kubernetes クラスターと統合するのに役立つオープンソース
 CNCF プロジェクトです。 Telepresence は、Kubernetes でトラフィック マネージャー ポッドを実行し、
開発者ワークステーションで Telepresence クライアント デーモンを実行することによって機能します。
トラフィック マネージャーは、接続をインターセプトし、クラスターと開発者コンピューターで実行されている
コンテナー間のトラフィックをルーティングできる双方向ネットワーク プロキシとして機能します。

・Choose the right base image
DOCKER HUBの安全なイメージを実現するためのステップを紹介している。適切なベース、イメージを選択する。
信頼できるソースから構築されていることを確認し、サイズを小さくする。
DOCKERFILEから独自のイメージを構築する場合は、最小限の基本イメージを必ず選択する。基本イメージが小さいと、
依存関係によってもたらされる脆弱性の数が最小限に抑えられる。2種類の基本イメージを使用することも検討する必要がある。

・Use multi-stage builds
マルチステージ ビルドは読みやすく保守しやすい最適化された DOCKERFILEを作成。複数のイメージを使用し、
特定のイメージから必要なアーティファクトのみを選択的にコピーできる。複雑さが大幅に軽減されるだけでなく、脆弱なアーティファクトが
実装される可能性も減る。

・Rebuild images
DOCKERFILEから構築されるイメージのスナップショットを紹介している。タグのないベース、イメージに依存すると、
再構築するたびに異なるイメージが取得される。パッケージインストーラーを使用してパッケージをインストールする場合も。

・Best practices for writing Dockerfiles
効率的なイメージを構築するためのベストプラクティスと方法を紹介している。DOCKERFILEから指示を読み取ることによって、
イメージを自動的に構築する。イメージは、それぞれが DOCKERFILE、命令を表す読み取り専用レイヤーで構成される。
基礎となるレイヤーの上に、新しい書き込み可能なレイヤーを追加する。コンテナーレイヤーとも呼ばれる新しい書き込み可能な
レイヤーも追加する。

・How to keep your images small
画像サイズを小さく保つための経験則を紹介している。適切なベースイメージから始め、マルチステージビルドを使用。
実稼働イメージを無駄のない状態に保ちながらデバッグを可能にする。

・Where and how to persist application data
コンテナーの書き込み可能レイヤーにデータを保存しないようにする方法を紹介している。ストレージドライバーを使用して、
コンテナーの書き込み可能リイヤーにデータを保存しない。容量が増加し、ボリュームやバインド、マウントを使用する場合
よりも効率が低くなる。

===============================================================

FROM ubuntu:22.04
COPY . /app
RUN make /app
CMD python /app/app.py

このコードはDockerfileで、Dockerイメージのビルドプロセスを定義しています。Dockerfileは、コンテナ化したいアプリケーションの環境を作成するための手順を定義します。具体的には、次のような内容を表しています：

FROM ubuntu:22.04: この行は、ベースとなるイメージを指定します。ベースイメージは、新しく作成されるイメージの基盤となるイメージで、その上に追加の設定やアプリケーションを構築します。ここでは、バージョン22.04のUbuntuイメージをベースとして使用します。

COPY . /app: この行は、現在のディレクトリ（.）のすべてのファイルとディレクトリを、新しく作成されるDockerイメージの/appディレクトリにコピーします。

RUN make /app: この行は、Dockerイメージをビルドする際に実行するコマンドを指定します。ここでは、make /appコマンドを実行します。このコマンドは/appディレクトリ内でMakefileが存在する場合、Makefileに定義されたビルド手順に従ってアプリケーションのビルドを行います。

CMD python /app/app.py: この行は、Dockerコンテナが起動したときに実行するコマンドを指定します。ここでは、python /app/app.pyコマンドを実行します。このコマンドは、/app/app.pyというPythonスクリプトを実行します。CMD命令はDockerfile内に1つしか存在できません。複数存在する場合は最後のCMD命令だけが有効になります。

このDockerfileにより、Ubuntu 22.04をベースに、現在のディレクトリの内容を/appにコピーし、make /appを実行してから、コンテナ起動時に/app/app.pyをPythonで実行するというDockerイメージが作成されます。

===============================================================

docker build -t myimage:latest -<<EOF: このコマンドはヒアドキュメントという形式を使用して一時的なDockerfileを作成し、それを使ってDockerイメージをビルドします。-t myimage:latestはビルドしたイメージにmyimage:latestという名前（タグ）をつけることを意味します。ヒアドキュメントは<<EOFとEOFで囲まれた部分で、それに続く行がその内容となります。

FROM busybox: Dockerfileの内容です。ベースイメージとしてbusyboxを使用します。busyboxは非常に小さなサイズのLinux環境を提供するイメージです。

COPY somefile.txt ./: Dockerfileの内容です。ビルドコンテキスト（この場合は一時的なDockerfileが存在するディレクトリ）からsomefile.txtをイメージの作業ディレクトリ（./）にコピーします。

RUN cat /somefile.txt: Dockerfileの内容です。イメージのビルド時にcat /somefile.txtコマンドを実行します。これはsomefile.txtの内容を表示するものです。

EOF: ヒアドキュメントの終了を示します。

COPY failed: stat /var/lib/docker/tmp/docker-builder249218248/somefile.txt: no such file or directory: これはエラーメッセージです。Dockerビルドプロセスがsomefile.txtをコピーしようとしたときにファイルが見つからなかったことを示しています。一時的なDockerfileは標準入力から提供されており、そのビルドコンテキスト（つまり、ファイルを探す場所）は実行しているディレクトリではなく、Dockerデーモンが実行されているホストのルートディレクトリになります。そのため、somefile.txtは見つけられないのです。これを解決するには、通常のDockerfileを作成し、その中でビルドを行うことが推奨されます。

===============================================================

FROM golang:1.20-alpine AS build: ベースとなるイメージとして、Go言語がインストールされたAlpine Linux（バージョン1.20）を指定します。また、AS buildというエイリアスを使って、このステージを"build"と呼びます。

RUN apk add --no-cache git: ベースとなるイメージ上でgitをインストールします。--no-cacheオプションは、パッケージキャッシュを削除してイメージサイズを小さく保つために使用されます。

WORKDIR /go/src/project/: 作業ディレクトリを/go/src/project/に設定します。

COPY go.mod go.sum /go/src/project/: ローカルのgo.modとgo.sumファイルを/go/src/project/にコピーします。

RUN go mod download: 依存関係をダウンロードします。

COPY . /go/src/project/: ローカルディレクトリの全てのファイルとディレクトリを/go/src/project/にコピーします。

RUN go build -o /bin/project: コピーしたソースコードをビルドし、実行可能ファイル/bin/projectを生成します。

FROM scratch: 新しいビルドステージを開始し、ベースイメージとしてscratchを使用します。scratchは空のイメージで、結果として得られるDockerイメージのサイズを小さくするのに役立ちます。

COPY --from=build /bin/project /bin/project: ビルドステージ（buildというエイリアスで参照）から生成された実行可能ファイル/bin/projectを新しいイメージの/bin/projectにコピーします。

ENTRYPOINT ["/bin/project"]: コンテナが起動したときに実行されるコマンドを設定します。ここでは先ほどコピーした実行可能ファイル/bin/projectが実行されます。

CMD ["--help"]: CMDは、ENTRYPOINTで指定されたプログラムに対してデフォルトの引数を提供します。これはユーザーがコンテナを起動するときに引数を指定しなかった場合に使われます。ここでは--helpがデフォルトの引数として設定されています。

===============================================================

RUN apt-get update && apt-get install -y \: RUN命令はDockerイメージのビルドプロセス中にシェルコマンドを実行します。この場合、まずapt-get updateコマンドを使用してUbuntuのパッケージリストを更新し、その後apt-get install -yコマンドを使用して指定したパッケージをインストールします。-yオプションは、全ての質問に対してyesを自動的に回答するためのもので、インストールプロセス中のユーザー入力を必要としないようにします。この行の最後の \は次の行にコマンドを続けるためのものです。

bzr \: bzrパッケージ（Bazaarバージョンコントロールシステム）をインストールするためのものです。最後の \は次の行にコマンドを続けるためのものです。

cvs \: cvsパッケージ（Concurrent Versions Systemバージョンコントロールシステム）をインストールするためのものです。最後の \は次の行にコマンドを続けるためのものです。

git \: gitパッケージ（Gitバージョンコントロールシステム）をインストールするためのものです。最後の \は次の行にコマンドを続けるためのものです。

mercurial \: mercurialパッケージ（Mercurialバージョンコントロールシステム）をインストールするためのものです。最後の \は次の行にコマンドを続けるためのものです。

subversion \: subversionパッケージ（Subversionバージョンコントロールシステム）をインストールするためのものです。最後の \は次の行にコマンドを続けるためのものです。

&& rm -rf /var/lib/apt/lists/*: このコマンドは、Dockerイメージのビルドプロセスの最後に/var/lib/apt/lists/*ディレクトリを削除します。このディレクトリはapt-get updateでダウンロードされるパッケージリストを格納する場所です。これを削除する理由は、不要なファイルをイメージから削除し、イメージのサイズを小さく保つためです。

===============================================================

このコードは、Dockerイメージにメタデータを追加するためのLABEL命令を使用しています。各LABEL命令はキーと値のペアを指定します。それぞれの行の説明は以下の通りです：

LABEL com.example.version="0.0.1-beta": バージョンを示すラベルを追加します。この例では、値として"0.0.1-beta"を設定しています。

LABEL vendor1="ACME Incorporated": ベンダー情報を示すラベルを追加します。この例では、値として"ACME Incorporated"を設定しています。

LABEL vendor2=ZENITH\ Incorporated: 別のベンダー情報を示すラベルを追加します。この例では、値としてZENITH Incorporatedを設定しています。ただし、空白文字を含む値を設定する場合は、全体をダブルクォーテーションで囲むか、エスケープ文字\を使用します。

LABEL com.example.release-date="2015-02-12": リリース日を示すラベルを追加します。この例では、値として"2015-02-12"を設定しています。

LABEL com.example.version.is-production="": 本番環境用かどうかを示すラベルを追加します。この例では、値として空の文字列（""）を設定しています。この値が空であることは、このバージョンが本番環境用ではないことを示している可能性があります。

LABEL命令によって設定されたメタデータは、Docker CLIのdocker inspectコマンドなどで確認することができます。また、オーケストレーションツール（例えば、Kubernetes）がこれらのラベルを利用してコンテナのスケジューリングや構成の管理を行うこともあります。

===============================================================

このコードは、RUN命令を使用してDockerイメージのビルドプロセス中にシェルコマンドを実行します。詳細は以下のとおりです：

RUN set -o pipefail && wget -O - https://some.site | wc -l > /number：

RUN: Dockerfileで使用される命令で、イメージのビルド中にシェルコマンドを実行します。

set -o pipefail: Bashシェルの設定を変更します。この設定はパイプライン内の任意のコマンドが失敗した場合に全体のステータスを非ゼロにします。つまり、このオプションを設定することで、パイプライン内のどのコマンドが失敗してもそれが捕捉されるようになります。

&&: 複数のコマンドを一緒に実行するための演算子です。左側のコマンド(set -o pipefail)が成功した場合にのみ、右側のコマンド(wget -O - https://some.site | wc -l > /number)が実行されます。

wget -O - https://some.site: wgetコマンドを使用して指定したURL(https://some.site)からデータをダウンロードします。-O -オプションはダウンロードしたデータを標準出力に送ることを意味します。

|: パイプ演算子を使用して、一つのコマンドの出力を別のコマンドの入力として渡します。この例では、wgetコマンドの出力がwc -lコマンドの入力となります。

wc -l: wcコマンドは「word count」の略で、テキストの行数、単語数、バイト数を数えるコマンドです。-lオプションを付けると、行数のみを数えます。

> /number: >演算子を使用して、wc -lコマンドの出力を/numberという名前のファイルにリダイレクトします。

全体として、このコマンドは「https://some.siteからデータをダウンロードし、その行数を数え、その結果を/numberというファイルに保存する」という操作を行います。また、`set -o pipefail`により、これらの操作のどれか一つでも失敗した場合にはエラーが返されます。

===============================================================

ENV PG_MAJOR=9.3: これはENV命令を使用して環境変数PG_MAJORを設定し、その値を9.3に設定しています。この環境変数は、後続のRUN命令やCMD命令、ENTRYPOINT命令等で使用できます。

ENV PG_VERSION=9.3.4: 同様に、ENV命令を使用して環境変数PG_VERSIONを設定し、その値を9.3.4に設定しています。

RUN curl -SL https://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres && …: RUN命令を使用してコマンドを実行します。このコマンドは、curlを使用してPostgreSQLのソースコード（バージョンは上で設定したPG_VERSIONの値）をダウンロードし、それをパイプ|を使用してtarコマンドに渡して解凍します。解凍先のディレクトリは/usr/src/postgresです。その後の&& …は、更に他のコマンドを連続して実行することを示していますが、ここでは詳細が省略されています。

ENV PATH=/usr/local/postgres-$PG_MAJOR/bin:$PATH: これはENV命令を使用してPATH環境変数を設定します。ここではPATHに新たにPostgreSQLのバイナリが格納されるディレクトリ/usr/local/postgres-$PG_MAJOR/binを追加しています。これにより、その後のコマンドからはこのディレクトリ内の実行可能ファイルが直接参照できるようになります。また、元々のPATHの値を保持するため、最後に:PATHを追加しています。

===============================================================


